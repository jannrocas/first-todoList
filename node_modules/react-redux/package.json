{
  "name": "react-redux",
  "version": "2.1.2",
  "description": "Official React bindings for Redux",
  "main": "./lib/index.js",
  "scripts": {
    "build:lib": "babel src --out-dir lib",
    "build:umd": "webpack src/index.js dist/react-redux.js --config webpack.config.development.js",
    "build:umd:min": "webpack src/index.js dist/react-redux.min.js --config webpack.config.production.js",
    "build": "npm run build:lib && npm run build:umd && npm run build:umd:min",
    "clean": "rimraf lib dist coverage",
    "lint": "eslint src test",
    "prepublish": "npm run clean && npm run build",
    "test": "mocha --compilers js:babel/register --recursive",
    "test:watch": "npm test -- --watch",
    "test:cov": "babel-node ./node_modules/isparta/bin/isparta cover ./node_modules/mocha/bin/_mocha -- --recursive"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/gaearon/react-redux.git"
  },
  "keywords": [
    "react",
    "reactjs",
    "hot",
    "reload",
    "hmr",
    "live",
    "edit",
    "flux",
    "redux"
  ],
  "author": {
    "name": "Dan Abramov",
    "email": "dan.abramov@me.com",
    "url": "http://github.com/gaearon"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/gaearon/react-redux/issues"
  },
  "homepage": "https://github.com/gaearon/react-redux",
  "devDependencies": {
    "babel": "^5.8.21",
    "babel-core": "^5.8.22",
    "babel-eslint": "^3.1.15",
    "babel-loader": "^5.3.2",
    "eslint": "^0.23",
    "eslint-config-airbnb": "0.0.6",
    "eslint-plugin-react": "^2.3.0",
    "expect": "^1.8.0",
    "isparta": "^3.0.3",
    "istanbul": "^0.3.17",
    "jsdom": "~5.4.3",
    "mocha": "^2.2.5",
    "mocha-jsdom": "~0.4.0",
    "react": "^0.14.0-beta3",
    "react-addons-test-utils": "^0.14.0-beta3",
    "react-dom": "^0.14.0-beta3",
    "redux": "^3.0.0",
    "rimraf": "^2.3.4",
    "webpack": "^1.11.0"
  },
  "dependencies": {
    "invariant": "^2.0.0"
  },
  "peerDependencies": {
    "redux": "^2.0.0 || ^3.0.0"
  },
  "readme": "React Redux\n=========================\n\nOfficial React bindings for [Redux](https://github.com/gaearon/redux).  \nPerformant and flexible.\n\n[![build status](https://img.shields.io/travis/rackt/react-redux/master.svg?style=flat-square)](https://travis-ci.org/rackt/react-redux) [![npm version](https://img.shields.io/npm/v/react-redux.svg?style=flat-square)](https://www.npmjs.com/package/react-redux)\n[![npm downloads](https://img.shields.io/npm/dm/react-redux.svg?style=flat-square)](https://www.npmjs.com/package/react-redux)\n[![redux channel on slack](https://img.shields.io/badge/slack-redux@reactiflux-61DAFB.svg?style=flat-square)](http://www.reactiflux.com)\n\n## Table of Contents\n\n- [Installation](#installation)\n- [React Native](#react-native)\n- [Quick Start](#quick-start)\n- [API](#api)\n  - [`<Provider store>`](#provider-store)\n  - [`connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])`](#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options)\n- [Troubleshooting](#troubleshooting)\n- [License](#license)\n\n## Installation\n\n```\nnpm install --save react-redux\n```\n\nReact Redux requires **React 0.13 or later.**\n\n## React Native\n\nWhat you get from `react-redux` is for React.  \nFor React Native, import from `react-redux/native` instead.\n\n## Quick Start\n\nReact bindings for Redux embrace the idea of [dividing “smart” and “dumb” components](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0).\n\nIt is advisable that only top-level components of your app (such as route handlers, for example) are aware of Redux. Components below them should be “dumb” and receive all data via props.\n\n\n<table>\n    <thead>\n        <tr>\n            <th></th>\n            <th scope=\"col\" style=\"text-align:left\">“Smart” Components</th>\n            <th scope=\"col\" style=\"text-align:left\">“Dumb” Components</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n          <th scope=\"row\" style=\"text-align:right\">Location</th>\n          <td>Top level, route handlers</td>\n          <td>Middle and leaf components</td>\n        </tr>\n        <tr>\n          <th scope=\"row\" style=\"text-align:right\">Aware of Redux</th>\n          <td>Yes</th>\n          <td>No</th>\n        </tr>\n        <tr>\n          <th scope=\"row\" style=\"text-align:right\">To read data</th>\n          <td>Subscribe to Redux state</td>\n          <td>Read data from props</td>\n        </tr>\n        <tr>\n          <th scope=\"row\" style=\"text-align:right\">To change data</th>\n          <td>Dispatch Redux actions</td>\n          <td>Invoke callbacks from props</td>\n        </tr>\n    </tbody>\n</table>\n\n### “Dumb” components are unaware of Redux\n\nLet’s say we have a `<Counter />` “dumb” component with a number `value` prop, and an `onIncrement` function prop that it will call when user presses an “Increment” button:\n\n```js\nimport { Component } from 'react';\n\nexport default class Counter extends Component {\n  render() {\n    return (\n      <button onClick={this.props.onIncrement}>\n        {this.props.value}\n      </button>\n    );\n  }\n}\n```\n\n### “Smart” components are `connect()`-ed to Redux\n\nHere’s how we hook it up to the Redux Store.\n\nWe will use the `connect()` function provided by `react-redux` to turn a “dumb” `Counter` into a smart component. The `connect()` function lets you specify *which exact* state from the Redux store your component wants to track. This lets you subscribe on any level of granularity.\n\n##### `containers/CounterContainer.js`\n\n```js\nimport { Component } from 'react';\nimport { connect } from 'react-redux';\n\nimport Counter from '../components/Counter';\nimport { increment } from '../actionsCreators';\n\n// Which part of the Redux global state does our component want to receive as props?\nfunction mapStateToProps(state) {\n  return {\n    value: state.counter\n  };\n}\n\n// Which action creators does it want to receive by props?\nfunction mapDispatchToProps(dispatch) {\n  return {\n    onIncrement: () => dispatch(increment())\n  };\n}\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Counter);\n\n// You can also pass an object instead of defining `mapDispatchToProps`:\n// export default connect(mapStateToProps, CounterActionCreators)(Counter);\n\n// Or you can pass `dispatch` down as a prop if you omit `mapDispatchToProps`:\n// export default connect(mapStateToProps)(Counter);\n\n// See more recipes in detailed connect() examples below.\n```\n\nWhether to put the `connect()` call in the same file as the “dumb” component, or separately, is up to you.  \nAsk yourself whether you’d want to reuse this component but bind it to different data, or not.\n\n### Nesting\n\nYou can have many `connect()`-ed components in your app at any depth, and you can even nest them. It is, however, preferable that you try to only `connect()` top-level components such as route handlers, so the data flow in your application stays predictable.\n\n### Support for Decorators\n\nYou might have noticed that we used parens twice when calling `connect()`. This is called partial application, and it lets people\nuse ES7’s proposed decorator syntax:\n\n```js\n// Unstable syntax! It might change or break in production.\n@connect(mapStateToProps)\nexport default class CounterContainer { ... }\n```\n\nDon’t forget decorators are experimental! They desugar to function calls anyway as the example above demonstrates.\n\n### Additional Flexibility\n\nThis is the most basic usage, but `connect()` supports many other patterns: just passing the vanilla `dispatch()` function down, binding multiple action creators, passing them in an `actions` prop, selecting parts of state and binding action creators depending on `props`, and so on. Check out the `connect()` docs below to learn more.\n\n### Injecting Redux Store\n\nFinally, how do we actually hook it up to the Redux store? We need to create the store somewhere at the root of our component hierarchy. For client apps, the root component is a good place. For server rendering, you can do this in the request handler.\n\nThe trick is to wrap the whole view hierarchy into a `<Provider>{() => ... }</Provider>` where `Provider` is imported from `react-redux`. One gotcha is that **the child of `Provider` must be a function**. This is to work around an issue about how context (undocumented feature we have to rely on to pass Redux data to components below) works in React 0.13. In React 0.14, you will be able to put your view hierarchy in `<Provider>` without wrapping it into a function.\n\n```js\nimport { Component } from 'react';\nimport { Provider } from 'react-redux';\n\nclass App extends Component {\n  render() {\n    // ...\n  }\n}\n\nconst targetEl = document.getElementById('root');\n\nReact.render((\n  <Provider store={store}>\n    {() => <App />}\n  </Provider>\n), targetEl);\n```\n\n## API\n\n### `<Provider store>`\n\nMakes the Redux store available to the `connect()` calls in the component hierarchy below. Normally, you can’t use `connect()` without wrapping the root component in `<Provider>`. (If you *really* need to, you can manually pass `store` as a prop to every `connect()`ed component, but we only recommend to do this for stubbing `store` in unit tests, or in non-fully-React codebases. Normally, you should just use `<Provider>`.)\n\n#### Props\n\n* `store`: (*[Redux Store](http://gaearon.github.io/redux/docs/api/Store.html)*): The single Redux store in your application.\n* `children`: (*Function*): Unlike most React components, `<Provider>` accepts a [function as a child](#child-must-be-a-function) with your root component. This is a temporary workaround for a React 0.13 context issue, which will be fixed when React 0.14 comes out.\n\n#### Example\n\n##### Vanilla React\n\n```js\nReact.render(\n  <Provider store={store}>\n    {() => <MyRootComponent />}\n  </Provider>,\n  rootEl\n);\n```\n\n##### React Router 0.13\n\n```js\nRouter.run(routes, Router.HistoryLocation, (Handler, routerState) => { // note \"routerState\" here\n  React.render(\n    <Provider store={store}>\n      {() => <Handler routerState={routerState} />} // note \"routerState\" here: important to pass it down\n    </Provider>,\n    document.getElementById('root')\n  );\n});\n```\n\n##### React Router 1.0\n\n```js\nReact.render(\n  <Provider store={store}>\n    {() => <Router history={history}>...</Router>}\n  </Provider>,\n  targetEl\n);\n```\n\n### `connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])`\n\nConnects a React component to a Redux store.\n\nIt does not modify the component class passed to it.  \nInstead, it *returns* a new, connected component class, for you to use.\n\n#### Arguments\n\n* [`mapStateToProps(state, [ownProps]): stateProps`] \\(*Function*): If specified, the component will subscribe to Redux store updates. Any time it updates, `mapStateToProps` will be called. Its result must be a plain object, and it will be merged into the component’s props. If you omit it, the component will not be subscribed to the Redux store. If `ownProps` is specified as a second argument, then `mapStateToProps` will be re-invoked whenever the component receives new props.\n\n* [`mapDispatchToProps(dispatch, [ownProps]): dispatchProps`] \\(*Object* or *Function*): If an object is passed, each function inside it will be assumed to be a Redux action creator. An object with the same function names, but bound to a Redux store, will be merged into the component’s props. If a function is passed, it will be given `dispatch`. It’s up to you to return an object that somehow uses `dispatch` to bind action creators in your own way. (Tip: you may use the [`bindActionCreators()`](http://gaearon.github.io/redux/docs/api/bindActionCreators.html) helper from Redux.) If you omit it, the default implementation just injects `dispatch` into your component’s props. If `ownProps` is specified as a second argument, then `mapDispatchToProps` will be re-invoked whenever the component receives new props.\n\n* [`mergeProps(stateProps, dispatchProps, ownProps): props`] \\(*Function*): If specified, it is passed the result of `mapStateToProps()`, `mapDispatchToProps()`, and the parent `props`. The plain object you return from it will be passed as props to the wrapped component. You may specify this function to select a slice of the state based on props, or to bind action creators to a particular variable from props. If you omit it, `Object.assign({}, ownProps, stateProps, dispatchProps)` is used by default.\n\n* [`options`] *(Object)* If specified, further customizes the behavior of the connector.\n  * [`pure`] *(Boolean)*: If true, implements `shouldComponentUpdate` and shallowly compares the result of `mergeProps`, preventing unnecessary updates, assuming that the component is a “pure” component and does not rely on any input or state other than its props and the selected Redux store’s state. *Defaults to `true`.*\n\n#### Returns\n\nA React component class that injects state and action creators into your component according to the specified options.\n\n#### Remarks\n\n* It needs to be invoked two times. The first time with its arguments described above, and a second time, with the component: `connect(mapStateToProps, mapDispatchToProps, mergeProps)(MyComponent)`.\n\n* It does not modify the passed React component. It returns a new, connected component, that you should use instead.\n\n* The `mapStateToProps` function takes a single argument of the entire Redux store’s state and returns an object to be passed as props. It is often called a **selector**. Use [reselect](https://github.com/faassen/reselect) to efficiently compose selectors and [compute derived data](http://gaearon.github.io/redux/docs/recipes/ComputingDerivedData.html).\n\n* **To use `connect()`, the root component of your app must be wrapped into `<Provider>{() => ... }</Provider>` before being rendered.** You may also pass `store` as a prop to the `connect()`ed component, but it's not recommended, because it's just too much trouble. Only do this for non-fully-React codebases or to stub the store in a unit test.\n\n#### Examples\n\n##### Inject just `dispatch` and don't listen to store\n\n```js\nexport default connect()(TodoApp);\n```\n\n##### Inject `dispatch` and every field in the global state\n\n>Don’t do this! It kills any performance optimisations because `TodoApp` will rerender after every action.  \n>It’s better to have more granular `connect()` on several components in your view hierarchy that each only  \n>listen to a relevant slice of the state.\n\n```js\nexport default connect(state => state)(TodoApp);\n```\n\n##### Inject `dispatch` and `todos`\n\n```js\nfunction mapStateToProps(state) {\n  return { todos: state.todos };\n}\n\nexport default connect(mapStateToProps)(TodoApp);\n```\n\n##### Inject `todos` and all action creators (`addTodo`, `completeTodo`, ...)\n\n```js\nimport * as actionCreators from './actionCreators';\n\nfunction mapStateToProps(state) {\n  return { todos: state.todos };\n}\n\nexport default connect(mapStateToProps, actionCreators)(TodoApp);\n```\n\n##### Inject `todos` and all action creators (`addTodo`, `completeTodo`, ...) as `actions`\n\n```js\nimport * as actionCreators from './actionCreators';\nimport { bindActionCreators } from 'redux';\n\nfunction mapStateToProps(state) {\n  return { todos: state.todos };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return { actions: bindActionCreators(actionCreators, dispatch) };\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TodoApp);\n```\n\n#####  Inject `todos` and a specific action creator (`addTodo`)\n\n```js\nimport { addTodo } from './actionCreators';\nimport { bindActionCreators } from 'redux';\n\nfunction mapStateToProps(state) {\n  return { todos: state.todos };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return bindActionCreators({ addTodo }, dispatch);\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TodoApp);\n```\n\n##### Inject `todos`, todoActionCreators as `todoActions`, and counterActionCreators as `counterActions`\n\n```js\nimport * as todoActionCreators from './todoActionCreators';\nimport * as counterActionCreators from './counterActionCreators';\nimport { bindActionCreators } from 'redux';\n\nfunction mapStateToProps(state) {\n  return { todos: state.todos };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    todoActions: bindActionCreators(todoActionCreators, dispatch),\n    counterActions: bindActionCreators(counterActionCreators, dispatch)\n  };\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TodoApp);\n```\n\n##### Inject `todos`, and todoActionCreators and counterActionCreators together as `actions`\n\n```js\nimport * as todoActionCreators from './todoActionCreators';\nimport * as counterActionCreators from './counterActionCreators';\nimport { bindActionCreators } from 'redux';\n\nfunction mapStateToProps(state) {\n  return { todos: state.todos };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    actions: bindActionCreators(Object.assign({}, todoActionCreators, counterActionCreators), dispatch)\n  };\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TodoApp);\n```\n\n##### Inject `todos`, and all todoActionCreators and counterActionCreators directly as props\n\n```js\nimport * as todoActionCreators from './todoActionCreators';\nimport * as counterActionCreators from './counterActionCreators';\nimport { bindActionCreators } from 'redux';\n\nfunction mapStateToProps(state) {\n  return { todos: state.todos };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return bindActionCreators(Object.assign({}, todoActionCreators, counterActionCreators), dispatch);\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TodoApp);\n```\n\n##### Inject `todos` of a specific user depending on props\n\n```js\nimport * as actionCreators from './actionCreators';\n\nfunction mapStateToProps(state, ownProps) {\n  return { todos: state.todos[ownProps.userId] };\n}\n\nexport default connect(mapStateToProps)(TodoApp);\n```\n\n##### Inject `todos` of a specific user depending on props, and inject `props.userId` into the action\n\n```js\nimport * as actionCreators from './actionCreators';\n\nfunction mapStateToProps(state) {\n  return { todos: state.todos };\n}\n\nfunction mergeProps(stateProps, dispatchProps, ownProps) {\n  return Object.assign({}, ownProps, {\n    todos: stateProps.todos[ownProps.userId],\n    addTodo: (text) => dispatchProps.addTodo(ownProps.userId, text)\n  });\n}\n\nexport default connect(mapStateToProps, actionCreators, mergeProps)(TodoApp);\n```\n\n## Troubleshooting\n\nMake sure to check out [Troubleshooting Redux](http://gaearon.github.io/redux/docs/Troubleshooting.html) first.\n\n### My views aren’t updating!\n\nSee the link above.\nIn short,\n\n* Reducers should never mutate state, they must return new objects, or React Redux won’t see the updates.\n* Make sure you either bind action creators with the `mapDispatchToProps` argument to `connect()` or with the `bindActionCreators()` method, or that you manually call `dispatch()`. Just calling your `MyActionCreators.addTodo()` function won’t work because it just *returns* an action, but does not *dispatch* it.\n\n### My views aren’t updating on route change with React Router 0.13\n\nIf you’re using React Router 0.13, you might [bump into this problem](https://github.com/gaearon/react-redux/issues/43). The solution is simple: whenever you use `<RouteHandler>` or the `Handler` provided by `Router.run`, pass the router state to it.\n\nRoot view:\n\n```js\nRouter.run(routes, Router.HistoryLocation, (Handler, routerState) => { // note \"routerState\" here\n  React.render(\n    <Provider store={store}>\n      {() => <Handler routerState={routerState} />} // note \"routerState\" here\n    </Provider>,\n    document.getElementById('root')\n  );\n});\n```\n\nNested view:\n\n```js\nrender() {\n  // Keep passing it down\n  return <RouteHandler routerState={this.props.routerState} />;\n}\n```\n\nConveniently, this gives your components access to the router state!\nYou can also upgrade to React Router 1.0 which shouldn’t have this problem. (Let us know if it does!)\n\n### My views aren’t updating when something changes outside of Redux\n\nIf your views depend on global state or [React “context”](www.youtube.com/watch?v=H7vlH-wntD4), you might find that views decorated with `connect()` will fail to update.\n\n>This is because `connect()` implements [shouldComponentUpdate](https://facebook.github.io/react/docs/component-specs.html#updating-shouldcomponentupdate) by default, assuming that your component will produce the same results given the same props and state. This is a similar concept to React’s [PureRenderMixin](https://facebook.github.io/react/docs/pure-render-mixin.html).\n\nThe _best_ solution to this is to make sure that your components are pure and pass any external state to them via props. This will ensure that your views do not re-render unless they actually need to re-render and will greatly speed up your application.\n\nIf that's not practical for whatever reason (for example, if you’re using a library that depends heavily on React context), you may pass the `pure: false` option to `connect()`:\n\n```\nfunction mapStateToProps(state) {\n  return { todos: state.todos };\n}\n\nexport default connect(mapStateToProps, null, null, {\n  pure: false\n})(TodoApp);\n```\n\nThis will remove the assumption that `TodoApp` is pure and cause it to update whenever its parent component renders. Note that this will make your application less performant, so only do this if you have no other option.\n\n### Could not find \"store\" in either the context or props\n\nIf you have context issues,\n\n1. [Make sure you don’t have a duplicate instance of React](https://medium.com/@dan_abramov/two-weird-tricks-that-fix-react-7cf9bbdef375) on the page.\n2. Make sure you didn’t forget to wrap your root component in [`<Provider>`](#provider-store).\n3. If you use React Router, something like `<Provider>{() => router}</Provider>` won’t work. Due to the way context works in React 0.13, it’s important that the `<Provider>` children are *created* inside that function. Just referencing an outside variable doesn’t do the trick. Instead of `<Provider>{() => router}</Provider>`, write `<Provider>{() => createRouter()}</Provider>` where `createRouter()` is a function that actually *creates* (and returns) the router.\n\n### Invariant Violation: addComponentAsRefTo(...): Only a ReactOwner can have refs. This usually means that you’re trying to add a ref to a component that doesn’t have an owner\n\nIf you’re using React for web, this usually means you have a [duplicate React](https://medium.com/@dan_abramov/two-weird-tricks-that-fix-react-7cf9bbdef375). Follow the linked instructions to fix this.\n\nIf you’re using React Native, make sure you’re importing `react-redux/native` both for `<Provider>` and any `connect()` call. Importing from `react-redux` will not work on React Native.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "react-redux@2.1.2",
  "_shasum": "4b26e02a7e049d1dc8ba5200999a3e153b28afc7",
  "_resolved": "https://registry.npmjs.org/react-redux/-/react-redux-2.1.2.tgz",
  "_from": "react-redux@>=2.1.1 <3.0.0"
}
